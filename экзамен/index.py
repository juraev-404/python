from ast import literal_eval # Ввод в формате любой структуры
from string import ascii_letters # Алавит ENG
from random import randint
import math
import matplotlib.pyplot as plt
import datetime


# №1

# В строке содержащей последовательность слов, разделенных запятыми 
# удалить все нечетные слова. Ответ представить в виде строки. Пример:
# строка 'SIX,SEVEN,EIGHT,NINE,TEN' будет преобразована в: 'SIX,EIGHT,TEN'.

li_1 = ['ONE', 'THREE', 'FIVE', 'SEVEN', 'NINE']

li = input('#1: ').split(',')
li_2 = []

for i in li:
    a = i.split(' ')[-1]
    if a in li_1:
        pass
    else:
        li_2.append(i)
print(li_2)


# №2

# Из списка списков элементами которого являются текстовые символы 
# собрать строку, в которой вложенные списки объединены в слова, а слова
# через запятую объединены в строку. Пример список вида [['E', 'e', 'n', 'y'],
# ['m', 'e', 'e', 'n', 'y'], ['m', 'i', 'n', 'e', 'y'], ['m', 'o', 'e']] будет преобразован в строку
# ‘Eeny,meeny,miney,moe’


li = literal_eval(input('#2: '))

a = [''.join(i) for i in li]
a = ','.join(a)
print(a)


# №3

# Используя генератор словарей (и не используя код вне него) инвертировать словарь, 
# т.е. сделать ключи словарая, его значениями и наоборото. Значения, которые в исходном 
# словаре повторяются не добавлять в итоговый словарь. Пример: {'a':1, 'b':3, 'c':4, 'd':3} -> {1:'a', 4:'c'}


dc = literal_eval(input('#3: '))

dc = {value: key for key, value in dc.items() if list(dc.values()).count(value) == 1}

print(dc)


# №4

# Используя генератор словарей (и не используя код вне него) преобразовать словарь в котором 
# ключами являются кортежи из целых чисел в словарь в котором ключом является среднее значение из чисел 
# исходного ключа, значение оставить прежним. Пример: {(2,4):'a', (1,1,1):'b', (2,3):'c'} -> {3.0:'a', 1.0:'b', 2.5:'c'}

dc = literal_eval(input('#4: '))

dc = {sum(list(k))/len(k): v for k, v in dc.items()}

print(dc)


# №5

# Используя генератор словарей (и не используя код вне него) преобразовать словарь в котором ключами 
# и значениями являются целые числа в список, в котором содержатся суммы исходных пар ключей и значений, 
# причем, в список включаются только суммы, являющиеся четными числами.  Пример: {2:4, 3:2, 12:6, 5:4, 1:3} -> [6, 18, 4]

dc = literal_eval(input('#5: '))

dc = [k + v for k, v in dc.items() if (k+v)%2==0]

print(dc)


# №6

# Используя генератор словарей (и не используя код вне него) преобразовать словарь в котором ключами являются 
# кортежи из целых чисел в словарь в котором ключом является максимальное значение из чисел исходного ключа, 
# значение оставить прежним. Пример: {(2,4):'a', (1,11,1):'b', (2,3):'c'} -> {4:'a', 11:'b', 3:'c'}

dc = literal_eval(input('#6: '))

dc = {max(k): v for k, v in dc.items()}

print(dc)


# №7

# Используя генератор словарей (и не используя код вне него) преобразовать словарь в котором ключами являются 
# кортежи из целых чисел в словарь в котором ключем является минимальное значение из чисел исходного ключа, 
# значение оставить прежним. Пример: {(2,4):'a', (1,2,3):'b', (12,3):'c'} -> {2:'a', 1:'b', 3:'c'}


dc = literal_eval(input('#7: '))

dc = {min(k): v for k, v in dc.items()}

print(dc)

# №8

# Используя генератор списков (и не используя код вне него) преобразовать список кортежей в список кортежей 
# по следующему правилу: если в кортеже четное количество элементов, то из него нужно удалить последний элемент. 
# В остальных случаях кортежи оставить неизменнымии. Приемер: [(1,3,4), (2,1), (6,), (2,2,2,1)] -> [(1,3,4), (2,), (6,), (2,2,2,)] 

li = literal_eval(input('#8: '))

li = [(i)[:-1] if len(i)%2==0 else i for i in li]

print(li)


# №9

# Используя генератор списков (и не используя код вне него) преобразовать два списка (в первом содержатся целые числа, 
# во втором строки, содержащие один символ) в словарь, в котором соответствующие друг другу пары значений из исходных 
# списков преобразованы в целочисленный ключ и строку состоящую из повторенных символов (количество повтарений равно значению ключа). 
# Пример [2, 4, 1, 3], ['a', 'b', 'c', 'd'] -> {2:'aa', 4:'bbbb', 1:'c', 3:'ddd'}

li_i = literal_eval(input('#9: '))
li_s = literal_eval(input('#9: '))

li = {k: v*k for k, v in zip(li_i, li_s)}

print(li)


# №10

# Используя генератор списков (и не используя код вне него) преобразовать список содержащий положительные 
# целые числа в список, элементами которого являются списки с длиной равной соответствующему числу в первом списке. 
# Содержимым вложенных списков являются последовательно идущие целые числа начиная с 1. Пример: 
# [3, 1, 4] -> [[1, 2, 3], [1], [1, 2, 3, 4]]

li = literal_eval(input('#10: '))

li = [[i+1 for i in range(el)] for el in li]

print(li)


# №11

# Используя генератор списков (и не используя код вне него) преобразовать строку по следующей логике: для каждого 
# символа исходной строки создать в итоговом списке строку, содержащую копии символа в количестве, равном номеру 
# символа рассчитанному с конца исходной строки. Пример: 'abcd' -> ['aaaa', 'bbb', 'cc', 'd']

st = input('#11: ')

li = [st[i]*(-1*(i-len(st))) for i in range(len(st))]

print((li))


# №12

# Используя генератор списков (и не используя код вне него) преобразовать строку по следующей логике: для каждого 
# символа исходной строки создать в итоговом списке строку, содержащую копии символа в количестве, равном номеру 
# символа в исходной строки. Пример: 'abcd' -> ['a', 'bb', 'ccc', 'dddd'] 


st = input('#12: ')

li = [(i+1)*st[i] for i in range(len(st))]

print((li))


# №13 -> №8


# №14

# На основе строки, представляющей из себя предложение, построить вложенный список, содержащий символы всех 
# слов в предложении. Пример: строка 'Eeny, meeny, miney, moe; Catch a tiger by his toe.' будет преобразована в: 
# [['E', 'e', 'n', 'y'], ['m', 'e', 'e', 'n', 'y'], ['m', 'i', 'n', 'e', 'y'], ['m', 'o', 'e'], ['C', 'a', 't', 'c', 'h'], 
# ['a'], ['t', 'i', 'g', 'e', 'r'], ['b', 'y'], ['h', 'i', 's'], ['t', 'o', 'e']]

st = input('#14: ')

li = [[i for i in el if i in ascii_letters] for el in st.split(' ')]

print(li)


# №15 

# Реализовать однонаправленный связанный список. Преобразовать строку 'Eeny, meeny, miney, moe; Catch a tiger by his toe.' 
# в связный список символов строки и удалить из него все элементы содержащие гласные буквы.

'''ещё не проходили связанные списоки'''


# #16

# Реализовать функцию nam_par, которая принимает на вход заранее неизвестное количество параметров и необязательный 
# параметр name в который можно передать строку. Функция возвращает словарь в котором переданные параметры являются 
# значениями, ключами для них являются соответсвующие (сопоставленные по порядку следования) символы из строки name. 
# Если строка name не задана, то значения присваиваются по порядку английского алфавита. 
# Пример 1: nam_par(7, 3, 1, 8, 10, 13, name='xyzafg') -> {'x':7, 'y':3, 'z':1, 'a':8, 'f':10, 'g':13} 
# Пример 2: nam_par(21, 'val', -3.5) -> {'a':21, 'b':'val', 'c':-3.5}

def nam_par(*args, name = ascii_letters):
    return {s: n for s, n in zip(name, args)}

print('#16: nam_par(7, 3, 1, 8, 10, 13, name="xyzafg")')
res = nam_par(7, 3, 1, 8, 10, 13, name='xyzafg')
print(res)
print('#16: nam_par(21, "val", -3.5)')
res_2 = nam_par(21, 'val', -3.5)
print(res_2)


# №17

# Реализовать функцию par_val, которая принимает на вход заранее неизвестное количество именованных 
# параметров (значения параметров - строки) и возвращает список имен параметров, которым соответствуют 
# строки, содержащие более двух слов. Пример: par_val(pp='abba war', fan='oneword', zr='a x') -> [pp, zr] 

def par_val(**kwargs):
    return [k for k, v in kwargs.items() if len(v.split(' '))>1]
print('#17: par_val(pp="abba war", fan="oneword", zr="a x")')
print(par_val(pp='abba war', fan='oneword', zr='a x'))


# №18 

# Реализовать функцию psort, которая принимает на вход набор заранее неизвестных поименованных параметров. 
# Функция возвращает список значений параметров отсортированный по именам параметров. Пример: 
# psort(c=21, a=22, ac=17, b=16) -> [22, 17, 16, 21] 

def psort(**kwargs):
    return [kwargs[k] for k in sorted(kwargs.keys())]

print('#18: psort(c=21, a=22, ac=17, b=16)')
print(psort(c=21, a=22, ac=17, b=16))


# №19

# Реализовать функцию psort, которая принимает на вход набор заранее неизвестных поименованных параметров. 
# Функция возвращает список имен параметров, отсортированный по значениям параметров. Пример: 
# psort(c=21, a=22, ac=17, b=16) -> [b, ac, c, a] 

def psort(**kwargs):
    dc = {k: v for v, k in kwargs.items()}
    return [dc[v] for v in sorted(dc.keys())]

print('#19: psort(c=21, a=22, ac=17, b=16)')
print(psort(c=21, a=22, ac=17, b=16))


# №20

# Реализовать функцию repl, которая принимает на вход строку и набор заранее неизвестных параметров. 
# Результатом функции является строка, в которой слова совпадающие с именами параметров заменены на значения параметров. 
# Пример: строка: 'replace my val abc', параметры my='s1', abc='fff' -> Результат: 'replace s1 val fff'

def repl(st, **kwargs):
    for k, v in kwargs.items():
        st = st.replace(k, v)
    return st

print('#20: repl("replace my val abc", my="s1", abc="fff")')
print(repl('replace my val abc', my='s1', abc='fff'))


# №21 

# Дана матрица размера M×N (M и N – четные числа). Поменять местами левую верхнюю и правую нижнюю четверти матрицы.

m, n = [int(i) for i in input('#21: ').split(' ')]
mt = [[str(i) for i in range(m)] for el in range(n)]
for i in mt:
    print(' '.join(i))
a = int(m/2)
for el in range(int(n/2)):
    mt[el][:a], mt[-1-el][a:] = mt[-1-el][a:], mt[el][:a]
print('')
for i in mt:
    print(' '.join(i))


# №22

# Дана матрица размера M×N. Найти номер ее строки с наибольшей суммой элементов и вывести данный
# номер, а также значение наибольшей суммы

mt = [[randint(-50, 50) for i in range(m)] for el in range(n)]

flag = [sum(mt[0]), 0]
print('#22: ')
for i in mt:
    print(i)
for i in mt:
    if sum(i) > flag[0]:
        flag[0], flag[1] = sum(i), mt.index(i)+1
print('\n',flag)


# №23

# Задана строка, в которой через запятую перечислены слова. Создать словарь, в котором ключами будут слова из строки, 
# а значениями - текст "номер {номер-слова-в-строке} в строке". Например, 'ten,one,five,two,three,four' преобразовать 
# в {'three': 'номер 5 в строке', 'one': 'номер 2 в строке', 'ten': 'номер 1 в строке', 'two': 'номер 4 в строке', 
# 'five': 'номер 3 в строке', 'four': 'номер 6 в строке'}.

st = input('#23: ')

dc = {i: f'номер {st.split(',').index(i)+1} в строке' for i in st.split(',')}

print(dc)


# №24

# Дана матрица размера M×N. Поменять местами столбец с номером 1 и последний из столбцов, содержащих только положительные элементы. 
# Если требуемых столбцов нет, то вывести матрицу без изменений.

mt = [[randint(-2, 5) for i in range(m)] for el in range(n)]

print('#23: ')

for i in mt:
    print(i)

print('')
    
flag = 0
for i in reversed(mt):
    for el in i:
        if el>0 or el == 0:
            flag += 1
        else:
            pass
    if flag == len(i):
        mt[mt.index(i)], mt[0] = mt[0], mt[mt.index(i)] 
        break
    else:
        flag = 0
        
for i in mt:
    print(i)


# №24

# Дана строка-предложение. Зашифровать ее, поместив вначале все символы, расположенные на четных позициях строки,
# а затем, в обратном порядке, все символы, расположенные на нечетных позициях 
# (например, строка «Программа» превратится в «ргамамроП»).

st = input('#24: ')
li = ['', '']

for i in st:
    if st.index(i)%2==0:
        li[0] += i
        st = st.replace(i,' ',1)
    else:
        li[1] += i
        st = st.replace(i,' ',1)

st = li[1]+str(li[0][::-1])
print(st)


# №25

# Дана строка, состоящая из русских слов, набранных заглавными буквами и разделенных пробелами (одним или несколькими).
# Найти количество слов, которые начинаются и заканчиваются одной и той же буквой.

st = input('#25: ').split()

flag = 0
for i in st:
    if i[0]==i[-1]:
        flag += 1

print(flag)


# №26 

# Пользователь поочередно вводит координаты точки в декартовой системе координат. Определить, 
# какой четверти принадлежит данная точка или на какой оси она находится. Расположение точки 
# вывести на экран. Найти произведение номера четверти на расстояние от этой точки до начала 
# координат и вывести его на экран. Если точка лежит на оси, считать, что номер четверти равен 0.

x, y = input('#26: ').split(' ')
x, y = int(x),int(y)

n = 0
if x > 0 and y > 0:
    n = ["Точка находится в первой четверти.", 1]
elif x < 0 and y > 0:
    n = ["Точка находится во второй четверти.", 2]
elif x < 0 and y < 0:
    n = ["Точка находится в третьей четверти.", 3]
elif x > 0 and y < 0:
    n = ["Точка находится в четвертой четверти.", 4]
elif x == 0 and y != 0:
    n = ["Точка находится на оси X.", 0]
elif x != 0 and y == 0:
    n = ["Точка находится на оси Y.", 0]
else:
    n = ["Точка находится в начале координат.", 0]

s = n[1]*((x**2+y**2)**0.5)

print(n[0], f"Произведение номера четверти на расстояние до начала координат: {s}", sep='\n')


# №27 

# Для произвольного значения x найти сумму первых пяти элементов убывающего ряда:
# Сравнить результат с точным значением синуса.


n = int(input('#27: '))

res = 0
for i in range(1, 6):
    res += ((-1)**(i+1))*(n**(2*i-1))/math.factorial(2*i-1)

print(f"Сумма первых 5 членов ряда: {res}")
print(f"Точное значение sin(x): {math.sin(n)}")
print(f"Абсолютная ошибка: {abs(res - math.sin(n))}")


# №28

# С помощью генератора создать в цикле список значений х от -π до +π (с небольшим произвольным шагом). 
# Для заданного списка рассчитать значения функций  и .

''' ? '''


# №29

# Для произвольного значения x найти сумму первых пяти элементов убывающего ряда:
# Сравнить результат с точным значением косинуса.


n = int(input('#29: '))

res = 0
for i in range(1, 6):
    res += ((-1)**(i+1))*(n**(2*i))/math.factorial(2*i)

print(f"Сумма первых 5 членов ряда: {res}")
print(f"Точное значение cos(x): {math.cos(n)}")
print(f"Абсолютная ошибка: {abs(res - math.cos(n))}")


#  №30

# Разработать программу вычисления дня недели для произвольной даты, например, 9 мая 1945 года, 12 апреля 1961 года

date = input('#30: ').split(' ')

month = {'января': 1, 'февраля': 2, 'марта': 3, 'апреля': 4, 'мая': 5, 'июня': 6, 'июля': 7, 'августа': 8, 'сентября': 9, 'октября': 10, 'ноября': 11, 'декабря': 12, }
w_day = datetime.datetime(int(date[2]), month[date[1]], int(date[0])).weekday()
days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
print(days[w_day-1])


# №31

# Разработать лямбда-функции вычисления по известной площади круга его радиуса и длины окружности.

res = lambda s: f'r = {(s/math.pi)**0.5}, C = {2*((s/math.pi)**0.5)*math.pi}'
print(res(int(input('#31: '))))


# №32

# В квадратной матрице, элементами которой являются случайные целые числа, размера n x n найти 
# среднее арифметическое положительных элементов главной диагонали и среднее арифметическое 
# отрицательных элементов побочной диагонали. Матрицу вывести на экран.

n = int(input('#32: '))

mt = [[randint(-5,5) for i in range(n)] for el in range(n)]
for i in mt:
    print(i)
l = [0, 0]
ul = [0, 0]
for i in range(n):
    if mt[i][i] > 0:
        l[0] += mt[i][i]
        l[1] += 1
    if mt[-1-i][i] < 0:
        ul[0] += mt[-1-i][i]
        ul[1] += 1

if l[1]== 0:
    l = 'нет положительных элементов главной диагонали'
else:
    l = f'среднее арифметическое положительных элементов главной диагонали: {l[0]/l[1]}'
if ul[1]== 0:
    ul = 'нет отрицательных элементов побочной диагонали'
else:
    ul = f'среднее арифметическое отрицательных элементов побочной диагонали: {ul[0]/ul[1]}'
print(l, ul, sep='\n')


# №33

# Результат сессии, состоящей из 3 экзаменов (История, Математика, Информатика), для студента 
# задается в виде списка, содержащего фамилию студента и 3 оценки по пятибалльной системе 
# (0-неявка, 2-неудовл., 3-удовл., 4-хорошо, 5-отлично). Результаты группы сохраняются в виде 
# словаря. Для группы выведите на экран: таблицу с результатами экзаменов; средний балл по 
# каждой дисциплин; средний балл для каждого студента.

dc = {
    'Иванов': [5, 4, 3],  # История: 5, Математика: 4, Информатика: 3
    'Петров': [3, 2, 5],
    'Сидоров': [4, 5, 5],
    'Кузнецов': [2, 3, 4],
    'Морозов': [0, 2, 3],
}
print('#33: ')
f = 0
s = 0
t = 0
for k, v in dc.items():
    print(k+': ', v, f'средний балл: {sum(v)/len(v)}')
    f += v[0]
    s += v[1]
    t += v[2]
f, s, t = f/len(dc), s/len(dc), t/len(dc)
print(f'средний балл по каждой дисциплин: История: {f}, Математика: {s}, Информатика: {t}')


# №34

# Реализовать функцию find_by_name, в которую можно передать произвольное количество параметров, 
# в результате функция вернет данные (в виде списка списков) только по людям, у которых в столбце 
# 'First Name' содержатся указанные имена. Заголовок csv-файла выглядит следующим образом: Id, First Name, Last Name, Age, Phone. 

li = [
    ["John", "Doe", 25, "+1-202-555-0134"],
    ["Jane", "Smith", 30, "+1-202-555-0173"],
    ["Emily", "Johnson", 22, "+1-202-555-0198"],
    ["Michael", "Brown", 35, "+1-202-555-0127"],
    ["Sarah", "Davis", 28, "+1-202-555-0156"]
]

def find_by_name(l, *args):
    li_2 = []
    for i in range(len(l)):
        if l[i][0] in args:
            li_2.append(l[i])
    return li_2

print("find_by_name(li, 'John', 'Jane', 'ssdas', 'aswq', 'Michael', 'dfsr', 'es', 'wef', 'Emily')")
print(find_by_name(li, 'John', 'Jane', 'ssdas', 'aswq', 'Michael', 'dfsr', 'es', 'wef', 'Emily'))


# №35

# Реализовать калькулятор для выражений с обыкновенными дробями. Число может быть записано как правильная, 
# неправильная или смешанная дробь (вид записи выражений приведен в примерах). Должны поддерживаться 
# операции: +, *. Выражение включает только одну операцию. Результат представить как правильную дробь. 
# Пример 1: 1 3/5 + 2/3 -> 2 4/15. Пример 2: 2/9 * 6/5 -> 4/15

op = input('#35: ')

if '+' in op:
    li = op.split(' + ')
    for i in li:
        if ' ' in i:
            li[li.index(i)] = [int(i.split(' ')[0]), [int(el) for el in i.split(' ')[1].split('/')]]
        else:
            li[li.index(i)] = [0, [int(el) for el in i.split('/')]]
    nok = math.lcm(li[0][1][1], li[1][1][1])
    zn = li[0][1][0]*(nok/li[0][1][1])+li[1][1][0]*(nok/li[1][1][1])
    s = li[0][0]+li[1][0]+zn//nok
    z = zn%nok
    d = nok
else:
    li = op.split(' * ')
    for i in li:
        if ' ' in i:
            li[li.index(i)] = [int(i.split(' ')[0]), [int(el) for el in i.split(' ')[1].split('/')]]
        else:
            li[li.index(i)] = [0, [int(el) for el in i.split('/')]]
    print(li)
    d = int(li[0][1][1])*int(li[1][1][1])
    z = int(li[0][1][0])*int(li[1][1][0])%d
    if int(li[0][0]) != 0 and int(li[1][0]) != 0:
        s = int(li[0][0])*int(li[1][0])+z//d
    elif int(li[0][0]) == 0 and int(li[1][0]) == 0:
        s = ''
    else:
        s = int(li[0][0])+int(li[1][0])+z//d

d = int(d)/math.gcd(int(d), int(z))
z = int(z)/math.gcd(int(d), int(z))


if s != '' and s != 0:
    s = str(int(s))
else:
    s = ''

if z != 0:
    z = f'{int(z)}/'
else:
    z = ''

if d != 0:
    d = str(int(d))
else:
    d = ''  


print(f'{s} {z+d}')


# №36

# 